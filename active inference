import numpy as np
import matplotlib.pyplot as plt
import pymdp

# Définir les états économiques possibles
states = {
    'low_wealth': (0, 1000),
    'low-medium_wealth': (1001, 5000),
    'medium_wealth': (5001, 20000),
    'medium-high_wealth': (20001, 100000),
    'high_wealth': (100001, float('inf'))
}

# Définir les observations possibles
observations = [
    'no_debt', 'low_debt', 'medium_debt', 'high_debt',
    'low_interest', 'medium_interest', 'high_interest',
    'low_price', 'medium_price', 'high_price']

debt_levels = {
    'no_debt': 0,
    'low_debt': (1, 100),
    'medium_debt': (101, 400),
    'high_debt': (401, 500)
}

interest_rates = {
    'low_interest': (0, 0.02),
    'medium_interest': (0.021, 0.05),
    'high_interest': (0.051, 0.1)
}

market_prices = {
    'low_price': (0, 80),
    'medium_price': (81, 120),
    'high_price': (121, float('inf'))
}

# Définir les actions possibles
actions = ['buy', 'hold', 'sell']

# Création de la matrice A
def create_A_matrix(states, observations):
    num_states = len(states)
    num_observations = len(observations)
    
    A = np.zeros((num_observations, num_states))
    
    for i in range(num_states):
        for j in range(num_observations):
            A[j, i] = 1.0 / num_observations  # Simplification: probabilité égale pour chaque observation

    return A

A = create_A_matrix(states, observations)

# Création de la matrice B
def create_B_matrix(states, actions):
    num_states = len(states)
    num_actions = len(actions)
    
    B = np.zeros((num_states, num_states, num_actions))
    
    for action_id in range(num_actions):
        for i in range(num_states):
            for j in range(num_states):
                B[j, i, action_id] = 1.0 / num_states  # Simplification: probabilité égale pour chaque transition

    return B

B = create_B_matrix(states, actions)

# Création de la matrice C
def create_C_matrix(observations):
    num_observations = len(observations)
    
    C = np.zeros((num_observations, 1))
    # L'agent ne veut pas être éjecté
    C[observations.index('low_debt')] = 1.0    
    # L'agent préfère les taux d'intérêts bas
    C[observations.index('low_interest')] = 0.75
    
    return C

C = create_C_matrix(observations)

class Asset:
    def __init__(self, qualities):
        self.qualities = qualities

class AgentState:
    def __init__(self, wealth, debt, assets, A, B, C):
        self.wealth = wealth
        self.debt = debt
        self.assets = assets  # Portefeuille d'actions
        self.A = A
        self.B = B
        self.C = C
        self.beliefs = np.ones(len(states)) / len(states)
        self.last_prices = np.zeros(len(self.assets))  # Stock des derniers prix d'actions vendues
        self.intrinsic_value
        self.min_price

    def update_intrinsic_value_and_min_price(self):
        self.intrinsic_value = np.mean([asset.intrinsic_value for asset in self.assets])
        self.min_price = np.mean([asset.min_price for asset in self.assets])

    def decide(self, current_observation):
        observation_idx = observations.index(current_observation)
        
        # Mise à jour des croyances basée sur l'observation actuelle
        self.beliefs = self.update_beliefs(self.beliefs, observation_idx)
        
        # Sélectionner une action basée sur les croyances actuelles
        action = self.sample_action(self.beliefs)
        
        return action

    def update_beliefs(self, beliefs, observation_idx):
        # Calculer la probabilité de l'observation pour chaque état
        observation_probs = self.A[observation_idx, :]
        
        # Mettre à jour les croyances
        updated_beliefs = beliefs * observation_probs
        updated_beliefs /= np.sum(updated_beliefs) # Normalise les croyances mises à jour pour que leur somme soit égale à 1.
        
        return updated_beliefs

    def sample_action(self, beliefs):
        # Calculer la valeur espérée de chaque action
        action_values = np.zeros(len(actions))
        for action_idx, action in enumerate(actions):
            for state_idx, state in enumerate(states):
                # Calcule la contribution de l'état actuel state_idx à la valeur espérée de l'action action_idx 
                action_values[action_idx] += beliefs[state_idx] * np.dot(self.B[state_idx, :, action_idx], self.C[:, 0])
        
        # Sélectionner l'action avec la valeur espérée maximale
        action_idx = np.argmax(action_values)
        
        return action_idx

class DecisionSpace:
    def __init__(self, agents):
        self.agents = agents

    def make_decisions(self):
        agents_to_remove = []
        for agent in self.agents:
            # Etape 1: L'agent tente de rembourser ses dettes
            if agent.debt > 0:
                if agent.wealth >= agent.debt:
                    # L'agent peut rembourser toute sa dette
                    agent.wealth -= agent.debt
                    agent.debt = 0
                else:
                    # L'agent ne peut pas rembourser du tout, il est hors jeu
                    agents_to_remove.append(agent)
                    continue

            # Etape 2: Mise à jour des préférences
            self.update_preferences(agent)

            # Etape 3: Offres ventes/achats
            self.broadcast_offers(agent, market_price)

            # Step 4: Décision d'achats/ventes
            self.decide_on_offers(agent, market_price)

    def update_preferences(self, agent):
        # Mettre à jour les préférences de l'agent en fonction de sa situation financière
        # Laisser blanc

    def broadcast_offers(self, agent, market_price):
        # A faire

    def decide_on_offers(self, agent, market_price):
        # A faire

class FinancialSystem:
    def __init__(self, agents, interest_rate):
        self.decision_space = DecisionSpace(agents)
        self.interest_rate = interest_rate

    def step(self):
        self.decision_space.make_decisions(self.interest_rate, market_price)    
        # A faire : definition  du prix du marché

# Initialisation des agents avec des portefeuilles d'actions
agents = [AgentState(wealth=1000, debt=500, assets=[Asset(qualities=[0.5, 0.6, 0.7])], A=A, B=B, C=C) for _ in range(10)]

# Initialisation du système financier
initial_interest_rate = 0.5 
market_price=83
financial_system = FinancialSystem(agents, initial_interest_rate)

# Simulation sur plusieurs étapes
for _ in range(10):
    financial_system.step()

# Simulation et visualisation des résultats
wealth_over_time = []
quality_over_time = []
prices_over_time = []

for _ in range(50):
    financial_system.step()
    wealth_over_time.append([agent.wealth for agent in agents])
    quality_over_time.append([np.mean([asset.quality for asset in agent.assets]) for agent in agents])
    prices_over_time.append(np.mean([np.mean([asset.quality for asset in agent.assets]) for agent in agents]))

# Visualisation
plt.figure(figsize=(12, 6))

# Évolution de la richesse
plt.subplot(1, 3, 1)
plt.plot(wealth_over_time)
plt.title('Évolution de la richesse')

# Évolution des prix du marché
plt.subplot(1, 3, 3)
plt.plot(prices_over_time)
plt.title('Évolution des prix du marché')

plt.tight_layout()
plt.show()
